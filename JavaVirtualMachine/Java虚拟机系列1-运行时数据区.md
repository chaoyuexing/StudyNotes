# Java虚拟机运行时数据区
![Java虚拟机内存模型] (http://xingshaonian.oss-cn-hangzhou.aliyuncs.com/img/JVMRunTimeDataArea.jpg)

.class文件字节码文件通过类加载器加载到JVM内存中时,JVM中的内存可以划分线程共享的数据区,和线程共有的区域,如上图所示

### 1.1 程序计数器

Java的线程调度策略是 `基于优先级的抢占式调度`,那么在多线程的线程切换执行的情况下,为了能够恢复到正确的执行位置,程序计数器就是记录着正在执行的虚拟机字节码指令的的地址,那也就意味着每一个线程都有一个属于自己的程序计数器,互不影响,也就是属于上图中所示的线程隔离的数据区.

 - 如果当前执行的是Native方法,计数器值为Undefined.
 - 唯一一个在Java虚拟机规范中没有任何OutOfMemoryError情况的区域.
 
### 1.2  虚拟机栈

我们经常笼统的把Java内存区分为堆内存和栈内存,这其中所指的`栈`就是`虚拟机栈`,虚拟机栈也是线程私有的,生命周期和线程相同,每个方法执行的时候都会创建一个栈帧(StackFrame)

![Java栈帧概念结构] (http://xingshaonian.oss-cn-hangzhou.aliyuncs.com/img/JavaStackFrameStructure.jpg)

每一个栈帧都包括了局部变量表,操作数栈,动态链接,方法返回地址和一些额外的附加信息

- 1:局部变量表用来存储`方法参数`和`方法内部定义的局部变量`,被编译在code属性表中的max_locals中,max_locals也是用U2表示 

- 2:操作数栈也被常叫做操作栈,它是一个后入先出栈,操作数栈的最大深度也在编译的时候写入到Code属性的`max_stack`,在任何情况下 操作数栈的深度都不会操作`max_stack`数据项的最大值  在code方法表中 `max_stack`属性用一个`U2`表示,也就是`65536`

关于U2代表的含义参考 [Java虚拟机类文件结构](https://github.com/chaoyuexing/StudyNotes/blob/master/JavaVirtualMachine/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA.md)

- 3:动态链接在方法内部需要调用其他方法和属性是使用,每个栈帧也就是每个方法都包含着一个指向运行时常量池所属方法的引用,这个引用就是为了支持方法调用过程中的动态链接. `运行时常量池见下文`

- 4:方法返回地址:当一个方法开始执行后,只有两种方式可以退出这个方法 
	- 正常完成出口(Normal Method Invocation Completion) 执行引擎遇到任意一个方法返回的字节码指令,是否有返回值和返回值的类型都根据返回指令来决定 `返回指令见下文`
	- 异常退出是指在方法在运行过程中遇到了异常,并且这个异常没有在方法内部得到处理,无论是Java虚拟机内部产生的异常,还是代码中产生的异常

无论当前方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。而虚拟机栈中的“返回地址”就是用来帮助当前方法恢复它的上层方法执行状态。一般来说，方法正常退出时，调用者的 PC 计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。

`方法退出的过程实际上就是把当前栈帧出栈`
返回指令
	
| 名称                           |  类型            |
| ------------------| -------- |
| ireturn 	 | 返回int类型 | 
| lreturn  | 返回long类型 | 
| freturn  | 返回float类型 | 
| dreturn  | 返回double类型| 
| areturn  | 返回对象引用 | 
| return | 返回void |

- 5:附加信息 虚拟机规范允许虚拟机实现增加一些规范中没有的信息到栈帧中,例如调试相干信息,取决于具体的虚拟机实现.

### 1.3 本地方法栈

本地方法栈和虚拟栈作用相似,虚拟机栈执行的是Java方法,本地方法栈则为Native方法,Sun HotSpot直接把本地方法栈和虚拟机栈合二为一

### 2.1 Java堆(Java Heap)

Java堆是Java虚拟机所管理的内存中最大的一块.Java堆是所有线程共享的一块内存区域, 唯一的目的就是存放对象实例

![Java堆结构图] (http://xingshaonian.oss-cn-hangzhou.aliyuncs.com/img/JavaHeapMemoryStructure.jpg)

上图不同的区域存放不同生命周期的对象.

几乎所有的对象实例和数组都要在堆上分配,随着技术的发展,栈上分配,标量替换优化技术会导致所有的对象都在堆上不那么绝对了.

### 2.2 方法区(Method Area)

方法区与Java堆一样,所有线程共享,用来存储已经被虚拟机加载的`类信息`,`常量`,`静态变量`,`即时编译器编译后的代码和数据`

注意：关于方法区，很多开发者会将其跟“永久区”混淆。所以我在这里对这两个概念进行一下对比：

- 方法区是 JVM 规范中规定的一块区域，但是并不是实际实现，切忌将规范跟实现混为一谈。不同的 JVM 厂商可以有不同版本的“方法区”的实现。

- HotSpot 在 JDK 1.7 以前使用“永久区”（或者叫 Perm 区）来实现方法区，在 JDK 1.8 之后“永久区”就已经被移除了，取而代之的是一个叫作“元空间（metaspace）”的实现方式。

总结一下就是：

- 方法区是规范层面的东西，规定了这一个区域要存放哪些数据。

- 永久区或者是 metaspace 是对方法区的不同实现，是实现层面的东西。

参考: 

- 深入理解Java虚拟机 周志明

- [ Android 工程师进阶 34 讲姜新星 ] (https://kaiwu.lagou.com/course/courseInfo.htm?sid=&courseId=67&lagoufrom=noapp#/detail/pc?id=1855)







 