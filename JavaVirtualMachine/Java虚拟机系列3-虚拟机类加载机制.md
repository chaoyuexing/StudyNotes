# Java虚拟机系列3-虚拟机类加载机制



![Java技术体系](http://xingshaonian.oss-cn-hangzhou.aliyuncs.com/img/JavaClassLifecycle.png)
虚拟机把我们上面.class 文件中描述的各种信息,通过校验,转换分析和初始化,最终加载到内存,这就是虚拟机的类加载机制

### 类加载的时机

以下的几种情况下,必须对类进行初始化

- 1: 遇到new,getstatic,putstatic,和invokstatic这4个字节码指令时,类如果没有进行初始化,需要先触发初始化, 对应Java 场景 new关键字 ,读取 或设置一个类的静态字段, 以及调用一个类的静态方法的时候.

- 2: 使用反射调用的时候,如果类没有进行初始化,则需要先触发初始化.

- 3: 当初始化一个类的时候,发现其父类还没有进行初始化,则需要先触发其父类的初始化.

- 4: 当虚拟机启动.用户需要指定一个需要执行的主类,虚拟机会先初始化这个主类.

- 5: Java1.7之后使用动态语言支持,methodHadle 实例调用的方法是静态或者存在静态字段时候,对应的类没有初始化,则需要先触发其初始化.

### 类加载过程

#### 加载

加载是类加载过程的一个阶段,名称相近,不要混淆.


- 	1): 通过一个类的全限定名来获取定义此类的二进制字节流
 	
-	2):将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
 	
-	3):在内存中生成一个代表这个类的java/lang/class对象,作为方法区这个类的各种数据的访问入口.
 	
 ` 通过全限定名获取定义类的二进制流,`没有指明二进制字节流从哪里获取,可以是zip包,例如Android的APK包,但是Android是基础Java改进的一种
 虚拟机,也可算是一种,jar,ear,war,aar等格式文件,可以通过网络获取,`运行时计算生成` 运行时计算生成的这个就是我们可以预想到最恐怖的事情,假如我们程序发生了一些问题,是可以通过人工智能的方式去预制一些异常的类型,然后自己生成对应二进制字节流,紧急的处理一些线上异常,然后给人工排除问题提供一个缓冲的时间,或者更恐怖的事情,就是直接定位了异常,并且解决.那样我们就都失业了

`加载阶段是开发人员可控性最强的`,Android的热更新就是在加载阶段对编译后的dex文件` dex文件一种特定Android手机虚拟机读取的文件格式`通过网络下发进行替换,达到热更新的效果.


#### 验证

验证输入连接阶段的第一步

- 1:文件格式校验

    	1):是否以魔数0XCAFEBABE开头

		2):主次版本号是否在当前虚拟机处理范围之内

		3):常量池的常量是否有不被支持的常量类型.

		4):指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量等等

- 2:元数据校验对Java字节码进行语义校验

- 3:字节码验证

- 4:符号引用校验 

#### 准备

准备是链接的第 2 步，这一阶段的主要目的是为类中的静态变量分配内存，并为其设置“0值”。比如：

 
 ```
 publuc static int value = 123;
 ```
 
 在准备过后初始值是0而不是123,有一些特殊情况,在字段属性表中存在ConstantValue属性
 
 例如
 
 ```
 publuc static final int value = 123;
 ```
 
 在编译时 Javac会吧value生成ConstantValue 在准备阶段将value赋值为123'
 
#### 解析

将常量池内的符号引用替换为直接引用的过程

符号引用就是我们上面讲到的引用的常量池的索引,但是常量池的索引不是具体的内存地址,  直接引用就是内存地址.  比如说你要找一个女朋友,女朋友就是一个符号引用,而具体你的女朋友是谁叫什么在哪里 就是直接引用.


#### 初始化

class 加载的最后一步,这一阶段是执行类构造器<clien>()方法的过程

例如上文的
 
 ```
 publuc static int value = 123;
 ```
 
 这个时候就会被赋值为123;
 
#### 卸载

当类被加载、连接和初始化后，它的生命周期就开始了，当代表类的Class对象不在被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载，从而结束类的声明周期。

由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。

`Java虚拟机自带的三种类加载加载的类在虚拟机的整个生命周期中是不会被卸载的，由用户自定义的类加载器所加载的类才可以被卸载`

动态替换就需要自定义的类加载器和对象的生命周期的完美配合

### 类加载器

- 1:BootStrap ClassLoader  启动类加载器:使用C++编写,是虚拟机自身的一部分 负责加载<Java_home>\lib目录中的 ,或者 被-XbootclassPath参数所指定的路径中的,如果需要把请求加载委派给启动类加载器,直接用null代替即可
- 2:ClassLoader 除了启动类加载器之外的所有类启动器的抽象父类
- 3:Extension ClassLoader 扩展类加载器:负责加载 <Java_home>\lib\ext目录中的,或者被java.ext.dirs系统变量所指定的路径中的所有类库,开发者可以直接使用
- 4Application ClassLoader 启动类加载器: 也叫系统类加载器,负责加载用户类路径上 classpath上的所指定的类库,开发者可以直接使用,我们通常自己没有自定义类加载器的情况下,程序中默认的类加载器

类加载采用了双亲委派模型

- 双亲委派模型 :每一个类加载器收到了类加载器的请求,他首先不会自己去尝试加载这个类,而是把他委派给父类加载器去完成,这样每个加载请求都会被传送到顶层的启动类加载器中,只有父类加载器无法加载,子加载器才去加载. 
举个很易懂的例子: 一个家庭中孩子得到一个桃子,他不能吃,给到自己的父亲,自己的父亲也不能吃,给到父亲的父亲,直到给到家庭中最高的长辈的时候,发现他也不吃,然后在反向传递桃子

双亲委派模型 是Java推荐给开发者的一种类加载器实现方式,如果想要破坏双亲委派模型,可以重写loadClass,如果想保持,应该重写 findClass 方法.


osgi, JNDI , 破坏了 双亲委派机制,需要了解 ,防止询问 双亲委派机制的缺点.






 
